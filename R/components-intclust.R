#' @include main.R
#' @include components.R
NULL

genIntComponents <- function(cutClusters, gInfo)
{
    clinds <- seq_along(unique(cutClusters))
    comps <- lapply(clinds, function(ci)
    {
        gNames <- rownames(gInfo)[cutClusters == ci]
        return(data.table(group = gNames, ret = gInfo[gNames, "rts"], mz = gInfo[gNames, "mzs"],
                          intensity = 1))
    })
    names(comps) <- paste0("CMP", seq_along(clinds))
    return(comps)
}

genIntComponentInfo <- function(cutClusters)
{
    clinds <- seq_along(unique(cutClusters))
    return(data.table(name = paste0("CMP", seq_along(clinds)),
                      size = sapply(clinds, function(ci) sum(cutClusters == ci))))
}

#' Components based on clustered intensity profiles.
#'
#' This class is derived from \code{\link{components}} and is used to store
#' hierarchical clustering information from intensity profiles of feature
#' groups.
#'
#' Objects from this class are generated by
#' \code{\link{generateComponentsIntClust}}
#'
#' @slot clusterm Numeric matrix with normalized feature group intensities that
#'   was used for clustering.
#' @slot distm Distance matrix that was used for clustering (obtained with
#'   \code{\link{daisy}}).
#' @slot clust Object returned by \code{\link{hclust}}.
#' @slot cutClusters A \code{list} with assigned clusters (same format as what
#'   \code{\link{cutree}} returns).
#' @slot gInfo The \code{\link{groupInfo}} of the feature groups object that was
#'   used.
#' @slot properties A list containing general properties and parameters used for
#'   clustering.
#'
#' @param x,obj A \code{componentsIntClust} object.
#' @param col The colour used for plotting. Set to \code{NULL} for automatic
#'   colours.
#' @param \dots Further options passed to \code{\link{heatmap.2}} /
#'   \code{\link{heatmaply}} (\code{plotHeatMap}), \code{\link{plot.dendrogram}}
#'   (\code{plot}) or \code{\link[graphics]{plot}} (\code{plotInt}).
#'
#' @references \insertRef{Scholle2018}{patRoon}
#'
#' @seealso \code{\link{components}} and \link{component-generation}
#'
#' @template components_noint
#' 
#' @export
componentsIntClust <- setClass("componentsIntClust",
                               slots = c(clusterm = "matrix", distm = "dissimilarity", clust = "hclust",
                                         cutClusters = "numeric", gInfo = "data.frame", properties = "list"),
                               contains = "components")
setMethod("initialize", "componentsIntClust",
          function(.Object, ...) callNextMethod(.Object, algorithm = "intclust", ...))


#' @describeIn componentsIntClust Accessor method to the \code{clust} slot,
#'   which was generated by \code{\link{hclust}}.
#' @export
setMethod("clusters", "componentsIntClust", function(obj) obj@clust)

#' @describeIn componentsIntClust Accessor method to the \code{cutClusters}
#'   slot. Returns a vector with cluster membership for each candidate (format
#'   as \code{\link{cutree}}).
#' @export
setMethod("cutClusters", "componentsIntClust", function(obj) obj@cutClusters)

#' @describeIn componentsIntClust Returns a list with properties on how the
#'   clustering was performed.
#' @export
setMethod("clusterProperties", "componentsIntClust", function(obj) obj@properties)

#' @describeIn componentsIntClust Manually (re-)cut the dendrogram.
#' @param k,h Desired number of clusters or tree height to be used for cutting
#'   the dendrogram, respectively. One or the other must be specified.
#'   Analogous to \code{\link{cutree}}.
#' @export
setMethod("treeCut", "componentsIntClust", function(obj, k = NULL, h = NULL)
{
    if (is.null(k) && is.null(h))
        stop("Either k or h should be specified")

    ac <- checkmate::makeAssertCollection()
    checkmate::assertCount(k, positive = TRUE, null.ok = TRUE, add = ac)
    checkmate::assertNumber(h, lower = 0, finite = TRUE, null.ok = TRUE, add = ac)
    checkmate::reportAssertions(ac)

    obj@cutClusters <- cutree(obj@clust, k, h)

    obj@components <- genIntComponents(obj@cutClusters, obj@gInfo)
    obj@componentInfo <- genIntComponentInfo(obj@cutClusters)

    return(obj)
})

#' @describeIn componentsIntClust Automatically (re-)cut the dendrogram using
#'   the \code{\link{cutreeDynamicTree}} function from
#'   \pkg{\link{dynamicTreeCut}}.
#'
#' @template dynamictreecut
#'
#' @export
setMethod("treeCutDynamic", "componentsIntClust", function(obj, maxTreeHeight, deepSplit,
                                                           minModuleSize)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertNumber(maxTreeHeight, 0, finite = TRUE, add = ac)
    checkmate::assertFlag(deepSplit, add = ac)
    checkmate::assertCount(minModuleSize, positive = TRUE, add = ac)
    checkmate::reportAssertions(ac)

    obj@cutClusters <- doDynamicTreeCut(obj@clust, maxTreeHeight,
                                        deepSplit, minModuleSize)

    obj@components <- genIntComponents(obj@cutClusters, obj@gInfo)
    obj@componentInfo <- genIntComponentInfo(obj@cutClusters)

    return(obj)
})

#' @describeIn componentsIntClust draws a heatmap using the
#'   \code{\link{heatmap.2}} or \code{\link{heatmaply}} function.
#' @param interactive If \code{TRUE} an interactive heatmap will be drawn (with
#'   \code{\link{heatmaply}}).
#' @param margins,cexCol Passed to \code{\link{heatmap.2}}
#' @return \code{plotHeatMap} returns the same as \code{\link{heatmap.2}} or
#'   \code{\link{heatmaply}}.
#' @aliases plotHeatMap
#' @export
setMethod("plotHeatMap", "componentsIntClust", function(obj, interactive = FALSE, col = NULL,
                                                        margins = c(6, 2), cexCol = 1,  ...)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertFlag(interactive, add = ac)
    checkmate::reportAssertions(ac)

    if (is.null(col))
        col <- colorRampPalette(c("blue", "yellow", "red"))(300)
    
    if (interactive)
        heatmaply::heatmaply(obj@clusterm, Colv = NA, distfun = function(d) dist(d, obj@properties$metric),
                             hclustfun = function(h) hclust(h, obj@properties$method),
                             scale = "none", colors = col, showticklabels = c(FALSE, FALSE), ...)
    else
        gplots::heatmap.2(obj@clusterm, Colv = NA, distfun = function(d) dist(d, obj@properties$metric),
                          hclustfun = function(h) hclust(h, obj@properties$method),
                          scale = "none", col = col, dendrogram = "row", ylab = "feature groups",
                          labRow = FALSE, margins = margins, cexCol = cexCol, ...)
})

#' @describeIn componentsIntClust makes a plot for all (normalized) intensity
#'   profiles of the feature groups within a given cluster.
#' @param index Numeric component/cluster index.
#' @param lty Passed to \code{\link{lines}}.
#' @export
setMethod("plotInt", "componentsIntClust", function(obj, index, pch = 20, type = "b",
                                                    lty = 3, col = NULL, ...)
{
    checkmate::assertInt(index, lower = 1, upper = length(obj@cutClusters), null.ok = TRUE)

    plotm <- obj@clusterm[rownames(obj@clusterm) %in% rownames(obj@gInfo)[obj@cutClusters == index], , drop = FALSE]
    nsamp <- ncol(plotm)

    plot(x = c(0, nsamp), y = c(0, max(plotm)), type = "n", xlab = "", ylab = "normalized intensity", xaxt = "n")
    axis(1, seq_len(nsamp), colnames(plotm), las = 2)

    if (is.null(col))
        col <- colorRampPalette(RColorBrewer::brewer.pal(12, "Paired"))(length(plotm))
    px <- seq_len(nsamp)
    for (i in seq_len(nrow(plotm)))
        lines(x = px, y = plotm[i, ], pch = pch, type = type, lty = lty, col = col[i], ...)

    invisible(NULL)
})

setMethod("plotIntHash", "componentsIntClust", function(obj, index, ...)
{
    plotm <- obj@clusterm[rownames(obj@clusterm) %in% rownames(obj@gInfo)[obj@cutClusters == index], , drop = FALSE]
    return(makeHash(plotm, ...))
})

#' @describeIn componentsIntClust generates a dendrogram from a given cluster
#'   object and optionally highlights resulting branches when the cluster is
#'   cut.
#' @param numericLabels Set to \code{TRUE} to label with numeric indices instead
#'   of (long) feature group names.
#' @templateVar withoutDots TRUE
#' @template plot_clust
#' @export
setMethod("plot", "componentsIntClust", function(x, pal = "Paired", numericLabels = TRUE,
                                                 colourBranches = length(x) < 50,
                                                 showLegend = length(x) < 20, ...)
{
    checkmate::assertString(pal, min.chars = 1)
    dendro <- as.dendrogram(x@clust)
    if (numericLabels)
        dendextend::labels(dendro) <- as.character(seq_along(x@cutClusters))
    plotDendroWithClusters(dendro, x@cutClusters, pal, colourBranches, showLegend, ...)
    invisible(NULL)
})


#' @templateVar class componentsIntClust
#' @template plotsil
#' @export
setMethod("plotSilhouettes", "componentsIntClust", function(obj, kSeq, pch = 16, type = "b", ...)
{
    checkmate::assertIntegerish(kSeq, lower = 2, any.missing = FALSE)
    doPlotSilhouettes(obj@clust, obj@distm, kSeq, pch, type, ...)
    invisible(NULL)
})

#' @details \code{generateComponentsIntClust} generates components based on
#'   intensity profiles of feature groups. Hierarchical clustering is performed
#'   on normalized (and optionally replicate averaged) intensity data and the
#'   resulting dendrogram is automatically cut with
#'   \code{\link{cutreeDynamicTree}}. The distance matrix is calculated with
#'   \code{\link{daisy}} and clustering is performed with \code{\link{hclust}}.
#'   The clustering of the resulting components can be further visualized and
#'   modified using the methods defined for \code{\link{componentsIntClust}}.
#'
#' @param method Clustering method that should be applied (passed to
#'   \code{\link{hclust}}).
#' @param metric Distance metric used to calculate the distance matrix (passed
#'   to \code{\link{daisy}}).
#' @param normFunc,average Passed to
#'   \code{\link[=as.data.table,featureGroups-method]{as.data.table}} to perform
#'   normalization and averaging of data.
#'
#' @template dynamictreecut
#'
#' @rdname component-generation
#' @export
setMethod("generateComponentsIntClust", "featureGroups", function(fGroups, method = "complete", metric = "euclidean",
                                                                  normFunc = max, average = TRUE,
                                                                  maxTreeHeight = 1, deepSplit = TRUE,
                                                                  minModuleSize = 1)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertClass(fGroups, "featureGroups", add = ac)
    checkmate::assertFunction(normFunc, add = ac)
    checkmate::assertString(metric, add = ac)
    checkmate::assertString(method, add = ac)
    checkmate::assertFlag(average, add = ac)
    checkmate::reportAssertions(ac)

    if (length(fGroups) == 0)
        return(componentsIntClust(components = list(), componentInfo = data.table(), clusterm = matrix(),
                                  distm = structure(list(), class = "dissimilarity"),
                                  clust = structure(list(), class = "hclust"), cutClusters = numeric(),
                                  gInfo = data.frame(), properties = list()))

    anas <- if (average) replicateGroups(fGroups) else analyses(fGroups)
    if (length(anas) < 2)
        stop(paste("Need at least >= 2", if (average) "replicate groups" else "analyses"))

    cat("Obtaining feature quantities... ")
    gTable <- as.data.table(fGroups, average = average, normFunc = normFunc)
    clusterm <- as.matrix(gTable[, anas, with = FALSE])
    rownames(clusterm) <- names(fGroups)
    cat("Done!\n")

    cat("Calculating distance matrix... ")
    distm <- daisy(clusterm, metric)
    cat("Done!\n")

    cat("Hierarchical clustering... ")
    clust <- hclust(distm, method)
    cat("Done!\n")

    cutClusters <- doDynamicTreeCut(clust, maxTreeHeight, deepSplit, minModuleSize)

    gInfo <- groupInfo(fGroups)
    comps <- genIntComponents(cutClusters, gInfo)
    cInfo <- genIntComponentInfo(cutClusters)

    return(componentsIntClust(components = comps, componentInfo = cInfo, clusterm = clusterm, distm = distm,
                              clust = clust, cutClusters = cutClusters, gInfo = gInfo,
                              properties = list(metric = metric, method = method, average = average)))
})
