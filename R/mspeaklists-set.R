#' @include main.R
#' @include mspeaklists.R
NULL

neutralizeMSPeakList <- function(pl, adduct)
{
    adductMZ <- adductMZDelta(adduct)

    adjPL <- function(x)
    {
        x <- copy(x)
        x[, mz := mz - adductMZ]
        x[, intensity := normalize(intensity, FALSE)]
        return(x)
    }
    
    if (!is.null(pl[["MS"]]))
        pl$MS <- adjPL(pl$MS)
    if (!is.null(pl[["MSMS"]]))
        pl$MSMS <- adjPL(pl$MSMS)
    
    return(pl)
}

syncMSPeakListsSetObjects <- function(MSPeakListsSet, i, j, reAverage)
{
    args <- list(reAverage = reAverage)
    if (!is.null(i))
        args <- c(args, list(i = i))
    if (!is.null(j))
        args <- c(args, list(j = j))
    
    # NOTE: assume that subsetting with non-existing i/j will not result in errors
    MSPeakListsSet@setObjects <- lapply(MSPeakListsSet@setObjects, function(o) do.call("[", args = c(list(x = o), args)))
    MSPeakListsSet@setObjects <- pruneList(MSPeakListsSet@setObjects, checkEmptyElements = TRUE)
    
    # re-generate
    MSPeakListsSet@ionizedPeakLists <- Reduce(modifyList, lapply(MSPeakListsSet@setObjects, peakLists))
    
    MSPeakListsSet@adducts <- MSPeakListsSet@adducts[names(MSPeakListsSet@setObjects)] # in case sets were removed
    
    # average ionized if (now) possible
    if (allSame(adducts(MSPeakListsSet)))
        MSPeakListsSet@ionizedAveragedPeakLists <- do.call(averageMSPeakLists,
                                                           c(list(MSPeakListsSet@ionizedPeakLists,
                                                                  MSPeakListsSet@origFGNames),
                                                             MSPeakListsSet@avgPeakListArgs))
    
    return(MSPeakListsSet)
}

#' @export
MSPeakListsSet <- setClass("MSPeakListsSet",
                           slots = c(adducts = "list", setObjects = "list", ionizedPeakLists = "list",
                                     ionizedAveragedPeakLists = "list", analysisInfo = "data.frame"),
                           contains = "MSPeakLists")

setMethod("initialize", "MSPeakListsSet",
          function(.Object, ...) callNextMethod(.Object, algorithm = "set", ...))

setMethod("sets", "MSPeakListsSet", function(obj) names(obj@setObjects))
setMethod("adducts", "MSPeakListsSet", function(obj) obj@adducts)

#' @describeIn MSPeakListsSet Get analysis information
#' @return \code{analysisInfo}: A \code{data.frame} containing a column with
#'   analysis name (\code{analysis}), its path (\code{path}), and other columns
#'   such as replicate group name (\code{group}) and blank reference
#'   (\code{blank}).
#' @export
setMethod("analysisInfo", "MSPeakListsSet", function(obj) obj@analysisInfo)

#' @describeIn MSPeakListsSet Shows summary information for this object.
#' @export
setMethod("show", "MSPeakListsSet", function(object)
{
    callNextMethod(object)
    printf("Sets: %s\n", paste0(sets(object), collapse = ", "))
    printf("Adducts: %s\n", paste0(sapply(adducts(object), as.character), collapse = ", "))
    if (length(object@setObjects[[1]]) > 0)
        printf("Original algorithm: %s\n", algorithm(object@setObjects[[1]]))
})

#' @describeIn MSPeakListsSet Accessor method to obtain the MS peak lists.
#' @return \code{peakLists} returns a nested list containing MS (and MS/MS where
#'   available) peak lists per feature group and per analysis. The format is:
#'   \code{[[analysis]][[featureGroupName]][[MSType]][[PeakLists]]} where
#'   \code{MSType} is either \code{"MS"} or \code{"MSMS"} and \code{PeakLists} a
#'   \code{\link{data.table}} containing all \emph{m/z} values (\code{mz}
#'   column) and their intensities (\code{intensity} column). In addition, the
#'   peak list tables may contain a \code{cmp} column which contains an unique
#'   alphabetical identifier to which isotopic cluster (or "compound") a mass
#'   belongs (only supported by MS peak lists generated by Bruker tools at the
#'   moment).
#'
#' @aliases peakLists
#' @export
setMethod("peakLists", "MSPeakListsSet", function(obj, neutralized = TRUE, sets = NULL)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertFlag(neutralized, add = ac)
    assertSets(obj, sets, add = ac)
    checkmate::reportAssertions(ac)
    
    if (!is.null(sets) && length(sets) > 0)
        obj <- obj[, sets = sets]
    
    if (neutralized)
        return(callNextMethod(obj))
    
    return(obj@ionizedPeakLists)
})

#' @describeIn MSPeakListsSet Accessor method to obtain the feature group averaged
#'   MS peak lists.
#' @return \code{averagedPeakLists} returns a nested list of feature group
#'   averaged peak lists in a similar format as \code{peakLists}.
#' @aliases averagedPeakLists
#' @export
setMethod("averagedPeakLists", "MSPeakListsSet", function(obj, neutralized = TRUE, sets = NULL)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertFlag(neutralized, add = ac)
    assertSets(obj, sets, add = ac)
    checkmate::reportAssertions(ac)
    
    if (!is.null(sets) && length(sets) > 0)
        obj <- obj[, sets = sets]
    
    if (neutralized)
        return(callNextMethod(obj))
    
    assertEqualAdducts(adducts(obj))
    
    return(obj@ionizedAveragedPeakLists)
})

#' @describeIn MSPeakListsSet Subset on analyses/feature groups.
#' @param reAverage Set to \code{TRUE} to regenerate averaged MS peak lists
#'   after subsetting analyses.
#' @export
setMethod("[", c("MSPeakListsSet", "ANY", "ANY", "missing"), function(x, i, j, ..., reAverage = TRUE,
                                                                      sets = NULL, drop = TRUE)
{
    ac <- checkmate::makeAssertCollection()
    assertSets(x, sets, add = ac)
    checkmate::assertFlag(reAverage, add = ac)
    checkmate::reportAssertions(ac)
    
    if (!is.null(sets) && length(sets) > 0)
        i <- mergeAnaSubsetArgWithSets(i, sets, analysisInfo(x))
    
    x <- callNextMethod(x, i, j, ..., reAverage = TRUE)

    if (!missing(i))
        x@analysisInfo <- x@analysisInfo[x@analysisInfo$analysis %in% names(peakLists(x)), ]
    
    if (!missing(i) || !missing(j))
        x <- syncMSPeakListsSetObjects(x, if (missing(i)) NULL else i, if (missing(j)) NULL else j, reAverage)
    
    return(x)
})

#' @describeIn MSPeakListsSet Extract a list with MS and MS/MS (if available) peak
#'   lists. If the second argument (\code{j}) is not specified the averaged peak
#'   lists for the group specified by the first argument (\code{i}) will be
#'   returned.
#' @export
setMethod("[[", c("MSPeakListsSet", "ANY", "ANY"), function(x, i, j, neutralized = TRUE)
{
    ac <- checkmate::makeAssertCollection()
    assertExtractArg(i, add = ac)
    if (!missing(j))
        assertExtractArg(j, add = ac)
    checkmate::assertFlag(neutralized, add = ac)
    checkmate::reportAssertions(ac)
    
    if (!neutralized && missing(j))
        assertEqualAdducts(adducts(x))
    
    if (neutralized)
        return(callNextMethod(x, i, j))
    
    if (!missing(j))
        return(ionize(x)[[i, j]])
    return(ionize(x)[[i]])
})

#' @describeIn MSPeakListsSet Returns all MS peak list data in a table.
#'
#' @param averaged If \code{TRUE} then feature group averaged peak list data is
#'   used.
#'
#' @template as_data_table-args
#'
#' @export
setMethod("as.data.table", "MSPeakListsSet", function(x, fGroups = NULL, averaged = TRUE,
                                                      neutralized = TRUE, sets = NULL)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertClass(fGroups, "featureGroupsSet", null.ok = TRUE, add = ac)
    checkmate::assertFlag(averaged, add = ac)
    checkmate::assertFlag(neutralized, add = ac)
    assertSets(x, sets, add = ac)
    checkmate::reportAssertions(ac)
    
    if (!is.null(sets) && length(sets) > 0)
        x <- x[, sets = sets]
    
    anaInfo <- analysisInfo(x) # get before ionizing    
    if (!neutralized)
    {
        x <- ionize(x)
        if (!is.null(fGroups))
            fGroups <- ionize(fGroups)
    }
    
    ret <- callNextMethod(x, fGroups = fGroups, averaged = averaged)
    
    if (!averaged) # add set column
    {
        ret[, set := anaInfo[match(analysis, anaInfo$analysis), "set"]]
        setcolorder(ret, "set")
    }
    
    return(ret[])
})

#' @export
setMethod("filter", "MSPeakListsSet", function(obj, ..., negate = FALSE, sets = NULL)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertFlag(negate, add = ac)
    assertSets(obj, sets, add = ac)
    checkmate::reportAssertions(ac)
    
    if (!is.null(sets) && length(sets) > 0)
    {
        if (negate)
            sets <- setdiff(obj@sets, sets)
        obj <- obj[, sets = sets]
    }
    
    if (length(list(...)) > 0)
    {
        obj <- callNextMethod(obj, ..., negate = negate)
        
        # synchronize other objects
        cat("Synchronizing set objects...\n")
        obj <- syncMSPeakListsSetObjects(obj, analyses(obj), groupNames(obj), reAverage = TRUE)
        cat("Done!\n")
    }
    
    return(obj)
})

#' @export
setMethod("plotSpec", "MSPeakListsSet", function(obj, groupName, analysis = NULL, MSLevel = 1, title = NULL,
                                                 useGGPlot2 = FALSE, xlim = NULL, ylim = NULL,
                                                 neutralized = TRUE, sets = NULL, perSet = TRUE,
                                                 mirror = TRUE, ...)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertString(groupName, min.chars = 1, add = ac)
    checkmate::assertString(analysis, min.chars = 1, null.ok = TRUE, add = ac)
    checkmate::assertChoice(MSLevel, 1:2, add = ac)
    assertXYLim(xlim, ylim, add = ac)
    aapply(checkmate::assertFlag, . ~ useGGPlot2 + neutralized + perSet, fixed = list(add = ac))
    assertSets(obj, sets, add = ac)
    checkmate::reportAssertions(ac)
    
    if (!is.null(sets) && length(sets) > 0)
        obj <- obj[, sets = sets]
    
    mySets <- get("sets", pos = 2)(obj)
    
    if (!perSet || length(mySets) == 1 || !is.null(analysis))
    {
        if (!neutralized)
            obj <- ionize(obj)
        return(callNextMethod(obj, groupName, analysis, MSLevel, title, useGGPlot2, xlim, ylim, ...))
    }
    
    specs <- lapply(obj@setObjects, getSpec, groupName = groupName, MSLevel = MSLevel, analysis = NULL)
    names(specs) <- mySets
    specs <- pruneList(specs)
    if (length(specs) == 0)
        return(NULL)
    
    specs <- lapply(specs, function(sp) { sp <- copy(sp); sp[, intensity := normalize(intensity, FALSE)]; return(sp) })
    specComb <- rbindlist(specs, idcol = "mergedBy")
    setorderv(specComb, "mz")

    if (is.null(title))
        title <- getMSPeakListPlotTitle(MSLevel, analysis, groupName)
    
    if (mirror && length(mySets) == 2)    
    {
        specComb[mergedBy == mySets[2], intensity := -intensity]
        if (is.null(ylim))
            ylim <- c(-1, 1)
    }
    
    plotData <- getMSPlotData(specComb, 1)
    ticks <- pretty(c(-specComb$intensity, specComb$intensity))
    if (useGGPlot2)
    {
        return(makeMSPlotGG(plotData) + ggtitle(title) +
                   ggplot2::scale_y_continuous(labels = abs(ticks)))
    }
    
    makeMSPlot(plotData, xlim, ylim, ylab = "Normalized intensity",
               main = title, yaxt = "n", ...)
    axis(2, at = ticks, labels = abs(ticks))
})

generateMSPeakListsSet <- function(fGroupsSet, generator, ..., avgSetParams,
                                   neutralizeByCharge)
{
    # UNDONE: move?
    assertAvgPListParams(avgSetParams)
    checkmate::assertChoice(neutralizeByCharge, c("none", "ms", "msms", "both"))
    
    # ionize all sets
    # calculate MS peak lists for each set
    # store set results in setObjects
    # store combined ionized results in ionizedPeakLists/ionizedAveragedPeakLists
    # store combined neutralized results in peakLists/averagedPeakLists
    
    ionizedFGroupsList <- sapply(sets(fGroupsSet), ionize, obj = fGroupsSet, simplify = FALSE)
    ionizedMSPeakLists <- sapply(ionizedFGroupsList, generator, ..., simplify = FALSE)
    
    neutralizedMSPL <- mapply(ionizedMSPeakLists, adducts(fGroupsSet), FUN = function(pl, add)
    {
        pl@peakLists <- lapply(pl@peakLists, lapply, neutralizeMSPeakList, adduct = add)
        pl@averagedPeakLists <- lapply(pl@averagedPeakLists, neutralizeMSPeakList, adduct = add)
        return(pl)
    }, SIMPLIFY = FALSE, USE.NAMES = TRUE)
    
    # combine (neutralized) MSPeakLists
    combPL <- Reduce(modifyList, lapply(neutralizedMSPL, peakLists))
    combPLIon <- Reduce(modifyList, lapply(ionizedMSPeakLists, peakLists))
    
    # UNDONE: set metadata?
    ret <- MSPeakListsSet(adducts = adducts(fGroupsSet), setObjects = ionizedMSPeakLists,
                          ionizedPeakLists = combPLIon, analysisInfo = analysisInfo(fGroupsSet),
                          peakLists = combPL, metadata = list(), avgPeakListArgs = avgSetParams,
                          origFGNames = names(fGroupsSet))
    
    if (allSame(adducts(ret)))
    {
        # average ionized spectra if all adducts are the same
        ret@ionizedAveragedPeakLists <- do.call(averageMSPeakLists, c(list(combPLIon, ret@origFGNames), avgSetParams))
    }
    
    return(ret)
}

MSPeakListsSetIonized <- setClass("MSPeakListsSetIonized", contains = "MSPeakLists")
setMethod("initialize", "MSPeakListsSetIonized",
          function(.Object, ...) callNextMethod(.Object, algorithm = "set_ionized", ...))
setMethod("ionize", "MSPeakListsSet", function(obj, sets)
{
    if (!is.null(sets) && length(sets) > 0)
        obj <- obj[, sets = sets]
    
    assertEqualAdducts(adducts(obj))
    
    return(MSPeakListsSetIonized(peakLists = obj@ionizedPeakLists,
                                 averagedPeakLists = obj@ionizedAveragedPeakLists,
                                 metadata = list(), avgPeakListArgs = obj@avgPeakListArgs,
                                 origFGNames = obj@origFGNames))
})

