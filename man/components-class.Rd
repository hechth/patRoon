% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TP.R, R/components.R, R/components-camera.R,
%   R/components-ramclustr.R
\docType{methods}
\name{length,TPPredictions-method}
\alias{length,TPPredictions-method}
\alias{components-class}
\alias{components}
\alias{componentsReduced-class}
\alias{componentsReduced}
\alias{componentTable,components-method}
\alias{componentTable}
\alias{componentInfo,components-method}
\alias{componentInfo}
\alias{groupNames,components-method}
\alias{length,components-method}
\alias{names,components-method}
\alias{show,components-method}
\alias{[,components,ANY,ANY,missing-method}
\alias{[[,components,ANY,ANY-method}
\alias{$,components-method}
\alias{as.data.table,components-method}
\alias{filter,components-method}
\alias{findFGroup,components-method}
\alias{findFGroup}
\alias{plotSpec,components-method}
\alias{plotEIC,components-method}
\alias{consensus,components-method}
\alias{componentsCamera-class}
\alias{componentsCamera}
\alias{componentsRC-class}
\alias{componentsRC}
\title{Component class}
\usage{
\S4method{length}{TPPredictions}(x)

\S4method{componentTable}{components}(obj)

\S4method{componentInfo}{components}(obj)

\S4method{groupNames}{components}(obj)

\S4method{length}{components}(x)

\S4method{names}{components}(x)

\S4method{show}{components}(object)

\S4method{[}{components,ANY,ANY,missing}(x, i, j, ..., drop = TRUE)

\S4method{[[}{components,ANY,ANY}(x, i, j)

\S4method{$}{components}(x, name)

\S4method{as.data.table}{components}(x)

\S4method{filter}{components}(
  obj,
  size = NULL,
  adducts = NULL,
  isotopes = NULL,
  rtIncrement = NULL,
  mzIncrement = NULL,
  negate = FALSE
)

\S4method{findFGroup}{components}(obj, fGroup)

\S4method{plotSpec}{components}(
  obj,
  index,
  markFGroup = NULL,
  useGGPlot2 = FALSE,
  xlim = NULL,
  ylim = NULL,
  ...
)

\S4method{plotEIC}{components}(obj, index, fGroups, rtWindow = 5, ...)

\S4method{consensus}{components}(obj, ...)
}
\arguments{
\item{obj, object, x}{The \code{component} object.}

\item{i, j}{A numeric or character value which is used to select components/feature groups by
their index or name, respectively (for the order/names see \code{names()/groupNames()}).\cr\cr For \code{[}: Can also be logical to perform logical selection
(similar to regular vectors). If missing all components/feature groups are selected.\cr\cr For \code{[[}: should be a scalar value. \code{j} is optional.}

\item{\dots}{For \code{plotEIC}: Further (optional) arguments passed to the
  \code{plotEIC} method for the \code{\link{featureGroups}} class. Note that
  the \code{colourBy}, \code{showPeakArea}, \code{showFGroupRect} and
  \code{topMost} arguments cannot be set as these are set by this method.

  For \code{plotSpec}: Further arguments passed to
  \code{\link[graphics]{plot}}.

  For \code{consensus}: \code{components} objects that should be used to
  generate the consensus.}

\item{drop}{ignored.}

\item{name}{The component name (partially matched).}

\item{size}{Should be a two sized vector with the minimum/maximum size of a
component. Set to \code{NULL} to ignore.}

\item{adducts}{Remove any feature groups within components that do not match
given adduct rules. If \code{adducts} is a logical then only results are
kept when an adduct is assigned (\code{adducts=TRUE}) or not assigned
(\code{adducts=FALSE}). Otherwise, if \code{adducts} contains one or more
\code{\link{adduct}} objects (or something that can be converted to it with
\code{\link{as.adduct}}) then only results are kept that match the given
adducts. Set to \code{NULL} to ignore this filter.}

\item{isotopes}{Only keep results that match a given isotope rule. If
\code{isotopes} is a logical then only results are kept with
(\code{isotopes=TRUE}) or without (\code{isotopes=FALSE}) isotope
assignment. Otherwise \code{isotopes} should be a numeric vector with
isotope identifiers to keep (\emph{e.g.} \samp{0} for monoisotopic results,
\samp{1} for \samp{M+1} results etc.). Set to \code{NULL} to ignore this
filter.}

\item{rtIncrement, mzIncrement}{Should be a two sized vector with the
minimum/maximum retention or mz increment of a homologous series. Set to
\code{NULL} to ignore.}

\item{negate}{If \code{TRUE} then filters are applied in opposite manner.}

\item{fGroup}{The name (thus a character) of the feature group that should be
searched for.}

\item{index}{The index of the component. Can be a numeric index or a
character with its name.}

\item{markFGroup}{If specified (\emph{i.e.} not \code{NULL}) this argument
can be used to mark a feature group in the plotted spectrum. The value
should be a character with the name of the feature group. Setting this to
\code{NULL} will not mark any peak.}

\item{useGGPlot2}{If \code{TRUE} then \pkg{\link{ggplot2}} is used for
plotting, otherwise base plot used. For \code{plotSpec}, \code{ggplot2}
allows nicely repelled text for annotation. However, base plot is generally
faster.}

\item{xlim, ylim}{Sets the plot size limits used by
\code{\link[graphics]{plot}}. Set to \code{NULL} for automatic plot sizing.}

\item{fGroups}{The \code{\link{featureGroups}} object that was used to
generate the components.}

\item{rtWindow}{Retention window: see the \code{plotEIC} method for the
\code{\link{featureGroups}} class.}
}
\value{
The subset operator (\code{"["}) and \code{filter} method return the
  data subset in an object from the \code{componentsReduced} class. This
  object does not contain any algorithm specific data and as such, algorithm
  specific methods (\emph{e.g.} \code{treeCut}) will not work on this object.
  The reason for this is that it is often very difficult or impossible to
  subset the algorithmic data.

\code{consensus} returns a \code{components} object that is produced
  by merging multiple specified \code{components} objects.
}
\description{
Contains data for feature groups that are related in some way. These
\emph{components} commonly include adducts, isotopes and homologues.
}
\details{
\code{components} objects are obtained from
\link[=component-generation]{component generators}.
}
\section{Methods (by generic)}{
\itemize{
\item \code{length}: Obtain total number of predictions.

\item \code{componentTable}: Accessor method for the \code{components} slot of a
\code{components} class. Each component is stored as a
\code{\link{data.table}}.

\item \code{componentInfo}: Accessor method for the \code{componentInfo} slot of a
\code{components} class.

\item \code{groupNames}: returns a \code{character} vector with the names of the
feature groups for which data is present in this object.

\item \code{length}: Obtain total number of components.

\item \code{names}: Obtain the names of all components.

\item \code{show}: Show summary information for this object.

\item \code{[}: Subset on components/feature groups.

\item \code{[[}: Extracts a component table, optionally filtered by a feature group.

\item \code{$}: Extracts a component table by component name.

\item \code{as.data.table}: Returns all component data in a table.

\item \code{filter}: Provides rule based filtering for components.

\item \code{findFGroup}: Returns the component id(s) to which a feature group
belongs.

\item \code{plotSpec}: Plot a \emph{pseudo} mass spectrum for a single
component.

\item \code{plotEIC}: Plot an extracted ion chromatogram (EIC) for all
feature groups within a single component.

\item \code{consensus}: Generates a consensus from multiple \code{components}
objects. At this point results are simply combined and no attempt is made to
merge similar components.
}}

\section{Slots}{

\describe{
\item{\code{components}}{List of all components in this object. Use the
\code{componentTable} method for access.}

\item{\code{componentInfo}}{A \code{\link{data.table}} containing general information
for each component. Use the \code{componentInfo} method for access.}
}}

\note{
\code{filter} Applies only those filters for which a component has data
  available. For instance, filtering by adduct will only filter any results
  within a component if that component contains adduct information.
}
\section{S4 class hierarchy}{
 \itemize{   \item{\code{\link{workflowStep}}}   \itemize{     \item{\strong{\code{\link{components}}}}     \itemize{       \item{\code{\link{componentsReduced}}}       \item{\code{\link{componentsCamera}}}       \item{\code{\link{componentsIntClust}}}       \item{\code{\link{componentsNT}}}       \item{\code{\link{componentsRC}}}       \item{\code{\link{componentsSet}}}     }   } }
}

\seealso{
\link{component-generation},  \code{\link{componentsNT}} and
  \code{\link{componentsIntClust}}
}
