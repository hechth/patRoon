% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multi-process.R
\name{executeMultiProcess}
\alias{executeMultiProcess}
\title{Simultaneous execution of system commands.}
\usage{
executeMultiProcess(
  commandQueue,
  finishHandler,
  timeoutHandler = function(...) TRUE,
  errorHandler = defMultiProcErrorHandler,
  procTimeout = NULL,
  printOutput = FALSE,
  printError = FALSE,
  showProgress = TRUE,
  waitTimeout = 50,
  maxProcAmount = getOption("patRoon.maxProcAmount"),
  batchSize = 1,
  delayBetweenProc = 0
)
}
\arguments{
\item{commandQueue}{A list with commands. Should contain \code{command}
(scalar string) and \code{args} (\code{character} vector). More user
defineds fields are allowed and useful to attach command information that
can be used in the finish, timeout and error handlers.}

\item{finishHandler}{A function that is called when a command has finished.
This function is typically used to process any results generated by the
command. The function is called right after spawning a new process, hence
processing results can occur while the next command is running in the
background. The function signature should be \code{function(cmd)} where
\code{cmd} is the queue data (from \code{commandQueue}) of the command that
has finished.}

\item{timeoutHandler}{A function that is called whenever a timeout for a
command occurs. Should return \code{TRUE} if execution of the command
should be retried. The function signature should be \code{function(cmd,
retries)} where \code{cmd} is the queue data for that command and
\code{retries} the number of times the command has been retried.}

\item{errorHandler}{Similar to \code{timeoutHandler}, but called whenever a
command has failed. The signature should be \code{function(cmd, exitStatus,
retries)}. The \code{exitStatus} argument is the exit code of the command
(may be \code{NA} in rare cases this is unknown). Other arguments are as
\code{timeoutHandler}.}

\item{workDir}{Sets the current working directory (if not \code{NULL}).}

\item{procTimeout}{The maximum time a process may consume before a timeout
occurs (in seconds). Set to \code{NULL} to disable
timeouts.}

\item{printOutput, printError}{Set to \code{TRUE} to print stdout/stderr
output to the console. Currently unused and untested.}

\item{showProgress}{Set to \code{TRUE} to display a progress bar.}

\item{waitTimeout}{Number of milliseconds to wait before checking if a new
process should be spawned.}

\item{maxProcAmount}{Maximum number of processes to run simultaneously.}

\item{batchSize}{Number of commands that should be executed in sequence per
processes. See details.}

\item{delayBetweenProc}{Minimum number of milliseconds to wait before
spawning a new process. Might be needed to workaround errors.}
}
\description{
Execute a queue of system commands in parallel.
}
\details{
This function executes a given queue with system commands in parallel to
speed up computation. Commands are executed in the background using the
\pkg{processx} package. A configurable maximum amount of processes are
created to execute multiple commands in parallel.

Multiple commands may be executed in sequence that are launched from a single
parent process (as part of a batch script on Windows or combined with the
shell AND operator otherwise). Note that in this scenario still multiple
processes are spawned. Each of these processes will manage a chunk of the
command queue (size defined by \code{batchSize} argument). This approach is
typically suitable for fast running commands: the overhead of spawning a new
process for each command from R would in this case be significant enough to
loose most of the speedup otherwise gained with parallel execution. Note that
the actual batch size may be adjusted to ensure that a maximum number of
processes are running simultaneously.

Other functionalities of this function include timeout and error handling.
}
\keyword{internal}
